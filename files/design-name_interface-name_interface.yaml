
uvmf:
  interfaces:
    <design-name>_<interface-name>: #interface name
      clock: clk
      reset: rst
      reset_assertion_level: <'False':#reset active low polarity 'True' :#reset active high polarity>

      config_constraints: [<specify configuration constraints>]
      config_vars: [<specify configuration variables>]

      hdl_typedefs: #Define any types used by the HDL side of the testbench
      - name: <design-name>_<interface-name>_<type-name>_t 
        type: <enum bit[n:0] {A = 3'b000, B = 3'b001, C = 3'b010}>
      hvl_typedefs: []

      parameters: # Any parameters defined here will impact be passed to multiple classes within the agent
      - name: <DESIGN-NAME>_<INTERFACE-NAME>_<PARAMETER-NAME>
        type: <int>
        value: <'8'>

      ports:  #Here we define all of the signal names, directions and widths for the agent/interface
      - name: <port-name>
        dir: <output or input> #Direction specified here is in relation to the testbench
        width: <'1' or PARAMETER_NAME>  
      
      response_info:
        data: []  #The data directive allows the user to specify what response data should be passed back from the driver to the originating sequence.
        operation: 1'b0 #The operation directive allows the user to define if the driver should pass any response data back to the sequence. 1â€™b0  tells the driver not to send back any response

      transaction_constraints:  #Defines any constraints to be used on the transaction variables
      - name: <constraint-name>_c
        value: '{ <variable-name> inside {A, B, C}; }' 

      transaction_vars: #Defines any variable to be used by the transaction class.
      - name: <variable-name>
        type: <<type-name>  or bit [<PARAMETER-NAME>-1:0]>
        iscompare: 'True'
        isrand: 'True'  